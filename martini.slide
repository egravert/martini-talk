The Martini Web Framework
A gentle introduction
14:00 27 Feb 2014
Tags: go webframework martini

Eric Gravert
Lead Software Engineer, ModCloth, Inc.
e.gravert@modcloth.com


* But First, a bit of background...

* Originally, we had net/http, and life was good

.play examples/http1.go /START OMIT/,/END OMIT/

- Register handlers with the DefaultServeMux
- Path matching is from most specific to least
- All handlers must of type func(ResponseWriter, *Request)


* net/http Continued...
.play examples/http2.go /START OMIT/,/END OMIT/

- DefaultServeMux can be replaced with a custom dispatcher
- Any type that implements ServeHTTP(w ResponseWriter, req *Request) is valid


* So what's the big deal?

*Pro's*

- Simple and Fast
- Provides enough out of the box functionality to roll your own services
- Highly extensible 

*Cons*

- DefaultServeMux does not support routing based on the HTTP Method
- Regex pattern matching not supported
- No session management, request context etc.
- Only supports the Handler interface

* Martini

* What is Martini?

- A Go package for developing web applications and services
- Microframework
- Extends the functionality of Go's built-in net/http package
- Uses reflection and dependency injection to add 

* Our first example
.play examples/martini1.go

* Out of the box features

.play examples/martini1.go /START OMIT/,/END OMIT/ HLCLASSIC

A Classic Martini includes the following services

- Logging
- Context
- Params
- Routing
- http.ResponseWriter & http.Request


- Full support for Method based routing
- Regex pattern matching of routes
- Route parameters can be accessed through `martini.Params`


* Martini introduces the following concepts
- Routing -  
- Handlers - A handler is any callable function
- Services - Functions that 
- Middleware


* Routing
.play examples/martini1.go /START OMIT/,/END OMIT/ HLROUTE

- Associates an HTTP Method and URL pattern to a series of Handlers
- Allows for named parameters in the URL
- Routes can be matched with regular expressions and globs as well
- Query parameters are available through the martini.Params service

* Handlers
Are callable functions that are mapped to a given request in the router

- Can return a string or string and int to return a result and status to the client
- Arguments for handlers are resolved using reflection and passed in values provided through services.
- If a handler returns a string, or int,string pair, the values will be written back to the ResponseWriter
- A route can specify multiple handlers


* Using Routing and Handlers together

  m.Get("/", func() string {
    return "hello world" // HTTP 200 : "hello world"
  })

  m.Get("/", func(params martini.Params) string {
    return "Hello " + params["name"]
  })

* Stacking handlers

  // router configuration
  m.Post("/book/new", Authorize, AddBook)

  // leverage sessions package to see if user
  // has access to the given resource
  func Authorize(session sessions..Session) {
    // validate session cookie
  }

  // use params packge and 
  func AddBook(params martin.Params, db sql.DB) {
    // parse the params and create a new book
  }

* Services
Services are the objects that can be injected into the handler argument list
they can be provided at two levels, globally, and per-request.

It is also possible to map a value to an interface.

* Middleware
Global handlers that are called before each request
* Router is the final middleware handler!
 Useful for providing services like authorization, logging, and error pages
 and serving static pages

* Render Middleware

Simplifies rendering HTML and JSON templates

- Supports layouts & supplies a `yield` function for layouts to access the current template
- Caching is supported and controlled through  the `MARTINI_ENV` env variable
- Uses html/template for the rendering language

  // add a middlware handler to enable rendering
  m.Use(render.Renderer(render.Options{Layout: "layout"}))

.code secondbrain/main.go /^func ShowNotes/,/^}/

* Binding Middleware
Binding middleware maps the values from an incoming request to a struct and passes it to the handler

- Uses struct tags to associate the request values to a field.
- Fields can be marked as required (supports nested requires) :)
- If a struct implements `binding.Validate`, the method will be called. If there is an error, an alternate handler can be specified. 


* Static
Part of  `ClassicMartini`, the static middleware serves up static assets that reside in a specified directory.

- Defaults to public in Classic
- multiple locations can be specified by using multiple instances of the static middleware
  m.Use(martini.Static("assets")
  m.Use(martini.Static("public")
- Is relative to your binary's working directory


* Testing
  - Can use the "net/http/httptest"
  - Make sure to design code to isolate the martini multiplexer from startup.
  - 


* Issues (here be opinions)
 - Does not provide a guide for how to structure a project
 - No tooling to help with packaging & deploying applications that include assets
 - Some of the middleware is very immature and is more useful as a guideline


* Further Reading
- [[https://github.com/codegangsta/martini][Martini Web Framework on Github]]
- [[https://github.com/martini-contrib][Martini Contrib on Github]]
- [[http://blog.gopheracademy.com/day-11-martini][Building a Christmas Wishlist with Martini]]
- [[https://gophercasts.io/][GopherCasts]]
